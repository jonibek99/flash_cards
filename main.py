from telegram import Update, ReplyKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes
import sqlite3
import wikipediaapi
from googletrans import Translator
from tinydb import TinyDB, Query
import time
import random
import requests
from salom import sardor

chat = TinyDB('id.json')
otash = TinyDB('topic.json')

wiki_wiki = wikipediaapi.Wikipedia(
    user_agent="MyTelegramBot/1.0 (contact: example@email.com)", 
    language="en"
)

def get_definition(word):
    url = f"https://api.dictionaryapi.dev/api/v2/entries/en/{word}"
    response = requests.get(url)
    if response.status_code == 200:
        data = response.json()
        try:
            definition = data[0]['meanings'][0]['definitions'][0]['definition']
            return definition
        except KeyError:
            return "‚ùå No definition found."
    else:
        return "üö´ Error: Could not fetch data."

async def help_data(update: Update, context: ContextTypes.DEFAULT_TYPE):
    a = sardor()
    await update.message.reply_text(a)

async def words(update: Update, context: ContextTypes.DEFAULT_TYPE):
    reply_key = [['‚ûï Add Words ‚úçÔ∏è'],
                 ['üìú Show All Words üìö', 'üåç Show All Translations üåê'],
                 ['‚ùå Exit üö™', 'üóëÔ∏è Delete Topic üßπ']]
    key = ReplyKeyboardMarkup(reply_key, resize_keyboard=True)
    await update.message.reply_text("üß†üí¨ Please choose one of the options below ‚¨áÔ∏è:", reply_markup=key)

async def delete(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("üóëÔ∏è If you want to delete a topic, just send me like this üëâ !topic_name üí•")

async def test(update: Update, context: ContextTypes.DEFAULT_TYPE):
    reply_key = [['üèÅ Begin üèÉ‚Äç‚ôÇÔ∏è', 'üìä Show Result üìà'],     
                 ['‚ùå Exit üö™']]
    key = ReplyKeyboardMarkup(reply_key, resize_keyboard=True)
    await update.message.reply_text("üéØüí° Choose one of the options below ‚¨áÔ∏è:", reply_markup=key)

async def begin_test(update: Update, context: ContextTypes.DEFAULT_TYPE):
    reply_key = [['üß† eng -- uzb', 'üß† uzb -- eng'],     
                 ['üìò definition -- eng'], ['‚ùå Exit üö™']]
    key = ReplyKeyboardMarkup(reply_key, resize_keyboard=True)
    await update.message.reply_text("üì¢ Send me topic name like: #eng/topic_name ‚¨áÔ∏è")

async def add_data(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("üìù Send topic and word like this: topic_name*word ‚úçÔ∏è")

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    Student = Query()
    chat_id = update.message.chat_id
    first_name = update.message.chat.first_name
    existing_user = chat.search(Student.chat_id == chat_id)
    if not existing_user:
        chat.insert({'chat_id': chat_id})

    relpy_key = [['üìö Words üè´', 'üë®‚Äçüè´ TEST üéì']]
    key = ReplyKeyboardMarkup(relpy_key)

    user_id = update.message.from_user.id
    table_name = 'a' + str(user_id)
    user_username = update.message.from_user.username
    if user_username:
        await update.message.reply_text(f"üëã Hello, @{user_username}! Please choose a button below. üì≤ if you need help pls send /help", reply_markup=key)
    else:
        user_first_name = update.message.from_user.first_name
        await update.message.reply_text(f"üëã Hello, {user_first_name}! Please choose a button below. üì≤ if you need help pls send /help", reply_markup=key)

    conn = sqlite3.connect("students.db")
    cursor = conn.cursor()
    cursor.execute(f"""
        CREATE TABLE IF NOT EXISTS {table_name} (
            id INTEGER PRIMARY KEY,
            topic TEXT,
            word TEXT,
            definition TEXT,
            uzbek TEXT
        )
    """)

async def add_word(update: Update, context: ContextTypes.DEFAULT_TYPE, text):
    try:
        word = text
        definition = get_definition(word)
        user_id = update.message.from_user.id
        table_name = 'a' + str(user_id)
        matn = text.split('*')
        topic_name = matn[0]
        word = matn[1]
        translator = Translator()
        result = translator.translate(word, src='en', dest='uz')
        page = wiki_wiki.page(word)
        if not page.exists():
            await update.message.reply_text(f"‚ùå No definition found for '{word}'.")
            return
        summary = page.summary
        sentences = summary.split('. ')
        short_definition = '. '.join(sentences[:2])
        clean_definition = short_definition.replace(word, "This term").replace(word.capitalize(), "This term")
        conn = sqlite3.connect("students.db")
        cursor = conn.cursor()
        cursor.execute(f"""
            INSERT INTO {table_name} (topic, word, definition, uzbek)
            VALUES (?, ?, ?, ?)
        """, (topic_name, word, clean_definition, result.text))
        conn.commit()
        await update.message.reply_text(f"‚úÖ Topic '{topic_name}' created and word '{word}' added successfully! üéâ")
    except Exception as e:
        await update.message.reply_text(f"‚ùå Error: {e}")

async def show_words(update: Update, context: ContextTypes.DEFAULT_TYPE):
    conn = sqlite3.connect("students.db")
    cursor = conn.cursor()
    user_id = update.message.from_user.id
    table_name = 'a' + str(user_id)

    cursor.execute(f"SELECT topic, word, definition FROM {table_name}")
    rows = cursor.fetchall()
    topics = {}
    for topic, word, definition in rows:
        if topic not in topics:
            topics[topic] = []
        topics[topic].append((word, definition))
    if not topics:
        await update.message.reply_text("‚ùå You don't have any words saved yet.")
        return
    message = ""
    for i, (topic, words) in enumerate(topics.items(), 1):
        message += f"\nüìö {i}. **Topic:** _{topic}_ ({len(words)} words):\n"
        for j, (word, definition) in enumerate(words, 1):
            message += f"    {j}) {word} ‚Äî {definition} üìñ\n"
        message += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
    await update.message.reply_text(message)

async def eng(update: Update, context: ContextTypes.DEFAULT_TYPE, text):
    text = text.strip().lower()
    user_id = update.message.from_user.id
    table_name = 'a' + str(user_id)
    conn = sqlite3.connect("students.db")
    cursor = conn.cursor()
    cursor.execute(f"SELECT 1 FROM {table_name} WHERE topic = ?", (text,))
    result = cursor.fetchall()
    otash.insert({'name': text})
    if len(result) >= 1:
        await update.message.reply_text(f"‚úÖ Topic \"{text}\" found with {len(result)} words.\nüß™ Test will begin! Send your answer sheet after finishing üõë")
        for count in [5, 4, 3, 2, 1]:
            time.sleep(1)
            await update.message.reply_text(f"‚è≥ {count}")
        await update.message.reply_text(f"üöÄ Starting test for '{text}'! üí•")
        cursor.execute(f"SELECT word FROM {table_name} WHERE topic = ?", (text,))
        rows = cursor.fetchall()
        word_list = [i[0] for i in rows]
        i = 1
        matn = f'üìò Topic: {text}\n\n'
        while len(word_list) > 0:
            word = random.choice(word_list)
            matn += f"‚ùì Q{i}: What does '{word}' mean in English?\n"
            word_list.remove(word)
            i += 1
        await update.message.reply_text(matn)
    else:
        await update.message.reply_text(f"‚ö†Ô∏è Topic not found: {text} ‚ùå")

async def show_uzbek(update: Update, context: ContextTypes.DEFAULT_TYPE):
    conn = sqlite3.connect("students.db")
    cursor = conn.cursor()
    user_id = update.message.from_user.id
    table_name = 'a' + str(user_id)
    cursor.execute(f"SELECT topic, word, uzbek FROM {table_name}")
    rows = cursor.fetchall()
    topics = {}
    for topic, word, uzbek in rows:
        if topic not in topics:
            topics[topic] = []
        topics[topic].append((word, uzbek))
    if not topics:
        await update.message.reply_text("‚ùå No translations found.")
        return
    message = ""
    for i, (topic, words) in enumerate(topics.items(), 1):
        message += f"\nüåê {i}. **Topic:** _{topic}_ ({len(words)} words):\n"
        for j, (word, uzbek) in enumerate(words, 1):
            message += f"    {j}) {word} ‚Äî {uzbek} üá∫üáø\n"
        message += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
    await update.message.reply_text(message)

async def delete_data(update: Update, context: ContextTypes.DEFAULT_TYPE, text):
    conn = sqlite3.connect("students.db")
    cursor = conn.cursor()
    user_id = update.message.from_user.id
    table_name = 'a' + str(user_id)
    cursor.execute(f"SELECT 1 FROM {table_name} WHERE topic = ?", (text,))
    result = cursor.fetchall()
    if len(result) >= 1:
        await update.message.reply_text(f"üóëÔ∏è Deleted topic \"{text}\" with {len(result)} words ‚ùå")
        cursor.execute(f"DELETE FROM {table_name} WHERE topic = ?", (text,))
        conn.commit()
    else:
        await update.message.reply_text(f"‚ö†Ô∏è Topic not found: {text} ‚ùå")

async def show_result(text, update: Update):
    text = text.strip().lower()
    user_id = update.message.from_user.id
    table_name = 'a' + str(user_id)
    conn = sqlite3.connect("students.db")
    cursor = conn.cursor()
    data = otash.all()
    last_name = data[-1].get('name') if data else "unknown"
    cursor.execute(f"SELECT uzbek FROM {table_name} WHERE topic = ?", (last_name,))
    rows = cursor.fetchall()
    uzbek_words = [row[0] for row in rows] if rows else []
    user_words = text.replace('answer', '').strip(',').split(',')
    correct = 0
    incorrect = 0
    max_length = max(len(user_words), len(uzbek_words))
    for i in range(max_length):
        user_word = user_words[i] if i < len(user_words) else None
        uzbek_word = uzbek_words[i] if i < len(uzbek_words) else None
        if user_word and uzbek_word and user_word.strip().lower() == uzbek_word.strip().lower():
            correct += 1 
        else:
            incorrect += 1 
    await update.message.reply_text(f"‚úÖ Correct: {correct}, ‚ùå Incorrect: {incorrect}")

async def show(update: Update, context: ContextTypes.DEFAULT_TYPE):
    last_answer = context.user_data.get('last_answer')
    if last_answer:
        await show_result(last_answer, update)
    else:
        await update.message.reply_text("‚ùó No 'answer' found yet.")

async def check(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text.lower().strip()
    if text.startswith('answer'):
        context.user_data['last_answer'] = text
    elif text.startswith('!'):
        await delete_data(update, context, text.replace('!', ''))
    elif text.startswith('*123'):
        msg = text[4:].strip()
        if not msg:
            await update.message.reply_text("‚ö†Ô∏è Message cannot be empty! üì¢")
            return
        for user in chat.all():
            try:
                await context.bot.send_message(chat_id=user['chat_id'], text=f"üì¢ Admin Message: {msg}")
            except Exception as e:
                print(f"Error: {e}")
        await update.message.reply_text("‚úÖ Sent to all users! üì©")
    elif text.startswith('#'):
        topic=text.replace('#','').strip()
        await eng(update, context, topic)
    elif '*' in text:
        await add_word(update, context, text)

def main() -> None:
    application = Application.builder().token("7981798770:AAGbSqQmu-Z4JJ5kD8P-wFwIIWaUvWmCOV4").build()

    application.add_handler(CommandHandler("help", help_data))
    application.add_handler(CommandHandler("start", start))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, check))
    
    application.add_handler(MessageHandler(filters.Regex('^üìä Show Result üìà$'), show))
    application.add_handler(MessageHandler(filters.Regex('^üìö Words üè´$'), words))
    application.add_handler(MessageHandler(filters.Regex('^üë®‚Äçüè´ TEST üéì$'), test))
    application.add_handler(MessageHandler(filters.Regex('^üóëÔ∏è Delete Topic üßπ$'), delete))
    application.add_handler(MessageHandler(filters.Regex('^üèÅ Begin üèÉ‚Äç‚ôÇÔ∏è$'), begin_test))
    application.add_handler(MessageHandler(filters.Regex('^üåç Show All Translations üåê$'), show_uzbek))
    application.add_handler(MessageHandler(filters.Regex('^‚ûï Add Words ‚úçÔ∏è$'), add_data))
    application.add_handler(MessageHandler(filters.Regex('^‚ùå Exit üö™$'), start))
    application.add_handler(MessageHandler(filters.Regex('^üìú Show All Words üìö$'), show_words))

    application.run_polling()

if __name__ == "__main__":
    main()